package com.denunciayabackend.authoritiesPanel.domain.model.entities;

import com.denunciayabackend.authoritiesPanel.domain.exceptions.AssignmentValidationException;
import com.denunciayabackend.authoritiesPanel.domain.exceptions.InvalidAssignmentStatusException;
import com.denunciayabackend.authoritiesPanel.domain.exceptions.InvalidStatusTransitionException;
import com.denunciayabackend.authoritiesPanel.domain.model.events.*;
import com.denunciayabackend.authoritiesPanel.domain.model.valueobjects.AssignmentStatus;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
/**
 * Entity representing the assignment of a complaint to a responsible user.
 * Tracks assignment lifecycle, including creation, reassignment, status updates,
 * completion, cancellation, and reopening. Generates domain events for every
 * significant state change.
 */
@Entity
@Table(name = "complaint_assignments")
@Getter
@Setter
public class ComplaintAssignment {

    /**
     * Unique identifier for the assignment.
     */
    @Id
    @Column(name = "id", nullable = false, length = 36)
    private String id;

    /**
     * Identifier of the complaint being assigned.
     */
    @Column(name = "complaint_id", nullable = false, length = 36)
    private String complaintId;

    /**
     * Identifier of the responsible user.
     */
    @Column(name = "responsible_id", nullable = false, length = 36)
    private String responsibleId;

    /**
     * Date and time the assignment was created or reassigned.
     */
    @Column(name = "assigned_date", nullable = false)
    private LocalDateTime assignedDate;

    /**
     * User who performed the assignment or reassignment.
     */
    @Column(name = "assigned_by", nullable = false, length = 100)
    private String assignedBy;

    /**
     * Current status of the assignment.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private AssignmentStatus status;

    /**
     * Optional notes associated with the assignment.
     */
    @Column(name = "notes", length = 500)
    private String notes;

    /**
     * Creation timestamp.
     */
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    /**
     * Timestamp for the most recent update.
     */
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    /**
     * Domain events generated by this entity.
     */
    @Transient
    private final List<AssignmentEvent> domainEvents = new ArrayList<>();

    /**
     * JPA default constructor.
     */
    protected ComplaintAssignment() {
    }

    /**
     * Internal constructor for creating new assignments.
     *
     * @param id             unique identifier
     * @param complaintId    complaint being assigned
     * @param responsibleId  assigned responsible user
     * @param assignedBy     user performing the assignment
     * @param notes          optional notes
     */
    private ComplaintAssignment(String id, String complaintId, String responsibleId,
                                String assignedBy, String notes) {
        this.id = id;
        this.complaintId = complaintId;
        this.responsibleId = responsibleId;
        this.assignedBy = assignedBy;
        this.notes = notes;
        this.status = AssignmentStatus.ACTIVE;
        this.assignedDate = LocalDateTime.now();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();

        registerEvent(new ComplaintAssignedEvent(id, complaintId, responsibleId, assignedBy, notes));
    }
    /**
     * Creates a new complaint assignment with validation.
     *
     * @param complaintId   ID of the complaint to assign
     * @param responsibleId ID of the responsible user
     * @param assignedBy    ID of the user performing the assignment
     * @param notes         optional notes
     * @return new instance of ComplaintAssignment
     * @throws AssignmentValidationException if any parameter is invalid
     */
    public static ComplaintAssignment create(String complaintId, String responsibleId,
                                             String assignedBy, String notes) {
        if (complaintId == null || complaintId.isBlank()) {
            throw new AssignmentValidationException("complaintId", "No puede ser nulo o vacío");
        }
        if (responsibleId == null || responsibleId.isBlank()) {
            throw new AssignmentValidationException("responsibleId", "No puede ser nulo o vacío");
        }
        if (assignedBy == null || assignedBy.isBlank()) {
            throw new AssignmentValidationException("assignedBy", "No puede ser nulo o vacío");
        }

        String id = "ASSIGN-" + java.util.UUID.randomUUID().toString().substring(0, 8).toUpperCase();

        return new ComplaintAssignment(id, complaintId, responsibleId, assignedBy, notes);
    }
    /**
     * Updates the status of the assignment.
     *
     * @param newStatus the new status to be applied
     * @param notes     optional notes describing the update
     * @throws AssignmentValidationException if the status is null
     * @throws InvalidStatusTransitionException if the status transition is not allowed
     */
    public void updateStatus(AssignmentStatus newStatus, String notes) {
        if (newStatus == null) {
            throw new AssignmentValidationException("status", "No puede ser nulo");
        }

        validateStatusTransition(this.status, newStatus);

        AssignmentStatus oldStatus = this.status;
        this.status = newStatus;
        if (notes != null && !notes.isBlank()) {
            this.notes = notes;
        }
        this.updatedAt = LocalDateTime.now();

        registerEvent(new AssignmentStatusUpdatedEvent(this.id, oldStatus, newStatus, notes));
    }
    /**
     * Reassigns the complaint to a new responsible user.
     *
     * @param newResponsibleId ID of the new responsible user
     * @param reassignedBy     user performing the reassignment
     * @param notes            optional notes
     * @throws AssignmentValidationException if parameters are invalid
     * @throws InvalidAssignmentStatusException if the current assignment is not active
     */

    public void reassign(String newResponsibleId, String reassignedBy, String notes) {
        if (newResponsibleId == null || newResponsibleId.isBlank()) {
            throw new AssignmentValidationException("newResponsibleId", "No puede ser nulo o vacío");
        }
        if (reassignedBy == null || reassignedBy.isBlank()) {
            throw new AssignmentValidationException("reassignedBy", "No puede ser nulo o vacío");
        }

        if (!this.isActive()) {
            throw new InvalidAssignmentStatusException(this.id, this.status.name(), "ACTIVE");
        }

        String oldResponsibleId = this.responsibleId;
        this.responsibleId = newResponsibleId;
        this.assignedBy = reassignedBy;
        this.notes = notes != null ? notes : this.notes;
        this.status = AssignmentStatus.REASSIGNED;
        this.assignedDate = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();

        registerEvent(new ComplaintReassignedEvent(this.id, oldResponsibleId, newResponsibleId, reassignedBy, notes));
    }
    /**
     * Marks the assignment as completed.
     *
     * @param notes optional notes explaining the completion
     * @throws InvalidStatusTransitionException if the assignment is already completed
     */
    public void completeAssignment(String notes) {
        if (this.status == AssignmentStatus.COMPLETED) {
            throw new InvalidStatusTransitionException(this.id, this.status, AssignmentStatus.COMPLETED);
        }

        this.status = AssignmentStatus.COMPLETED;
        if (notes != null && !notes.isBlank()) {
            this.notes = notes;
        }
        this.updatedAt = LocalDateTime.now();

        registerEvent(new AssignmentCompletedEvent(this.id, this.complaintId, this.responsibleId, notes));
    }
    /**
     * Cancels the assignment.
     *
     * @param notes optional notes explaining the cancellation
     * @throws InvalidStatusTransitionException if the assignment is already cancelled
     */
    public void cancelAssignment(String notes) {
        if (this.status == AssignmentStatus.CANCELLED) {
            throw new InvalidStatusTransitionException(this.id, this.status, AssignmentStatus.CANCELLED);
        }

        this.status = AssignmentStatus.CANCELLED;
        if (notes != null && !notes.isBlank()) {
            this.notes = notes;
        }
        this.updatedAt = LocalDateTime.now();

        registerEvent(new AssignmentCancelledEvent(this.id, this.complaintId, this.responsibleId, notes));
    }
    /**
     * Reopens a previously completed or cancelled assignment.
     *
     * @param notes optional notes explaining the reopening
     * @throws InvalidAssignmentStatusException if the assignment cannot be reopened
     */
    public void reopenAssignment(String notes) {
        if (this.status != AssignmentStatus.COMPLETED && this.status != AssignmentStatus.CANCELLED) {
            throw new InvalidAssignmentStatusException(this.id, this.status.name(), "COMPLETED o CANCELLED");
        }

        AssignmentStatus oldStatus = this.status;
        this.status = AssignmentStatus.ACTIVE;
        if (notes != null && !notes.isBlank()) {
            this.notes = notes;
        }
        this.updatedAt = LocalDateTime.now();

        registerEvent(new AssignmentStatusUpdatedEvent(this.id, oldStatus, AssignmentStatus.ACTIVE, notes));
    }
    /**
     * Checks if the assignment is currently active.
     *
     * @return true if active, false otherwise
     */
    public boolean isActive() {
        return this.status == AssignmentStatus.ACTIVE;
    }
    /**
     * Validates whether going from one status to another is allowed.
     *
     * @param from the current status
     * @param to   the target status
     * @throws InvalidStatusTransitionException if the transition is invalid
     */
    private void validateStatusTransition(AssignmentStatus from, AssignmentStatus to) {
        boolean isValidTransition = true;

        if (from == AssignmentStatus.COMPLETED || from == AssignmentStatus.CANCELLED) {
            if (to != AssignmentStatus.ACTIVE) {
                isValidTransition = false;
            }
        } else if (from == AssignmentStatus.REASSIGNED) {
            if (to == AssignmentStatus.REASSIGNED) {
                isValidTransition = false;
            }
        }

        if (!isValidTransition) {
            throw new InvalidStatusTransitionException(this.id, from, to);
        }
    }
    /**
     * Registers a new domain event.
     *
     * @param event the event to add
     */
    public void registerEvent(AssignmentEvent event) {
        this.domainEvents.add(event);
    }
    /**
     * Retrieves all domain events generated by this entity.
     *
     * @return list of domain events
     */
    public List<AssignmentEvent> getDomainEvents() {
        return new ArrayList<>(this.domainEvents);
    }

    /**
     * Clears all registered domain events.
     */
    public void clearDomainEvents() {
        this.domainEvents.clear();
    }
}