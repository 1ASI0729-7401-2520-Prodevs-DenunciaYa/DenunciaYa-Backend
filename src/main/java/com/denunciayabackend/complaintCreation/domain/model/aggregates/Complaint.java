package com.denunciayabackend.complaintCreation.domain.model.aggregates;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import com.denunciayabackend.complaintCreation.domain.model.commands.CreateComplaintCommand;
import com.denunciayabackend.complaintCreation.domain.model.commands.UpdateComplaintCommand;
import com.denunciayabackend.complaintCreation.domain.model.entities.Evidence;
import com.denunciayabackend.complaintCreation.domain.model.entities.TimelineItem;
import com.denunciayabackend.complaintCreation.domain.model.valueobjects.ComplaintId;
import com.denunciayabackend.complaintCreation.domain.model.valueobjects.ComplaintPriority;
import com.denunciayabackend.complaintCreation.domain.model.valueobjects.ComplaintStatus;
import com.denunciayabackend.shared.domain.model.aggregates.AuditableAbstractAggregateRoot;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.AttributeOverrides;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Embedded;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Lob;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;

@Entity(name = "ComplaintCreation")
@Table(name = "complaints")
@JsonInclude(JsonInclude.Include.NON_NULL)
public class Complaint extends AuditableAbstractAggregateRoot<Complaint> {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "value", column = @Column(name = "complaint_id", unique = true))
    })
    private ComplaintId complaintId;

    @Column(nullable = false)
    private String category;

    @Column(nullable = false)
    private String department;

    @Column(nullable = false)
    private String city;

    @Column(nullable = false)
    private String district;

    @Column(nullable = false)
    private String location;

    @Lob
    private String referenceInfo;

    @Lob
    @Column(nullable = false)
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ComplaintStatus status = ComplaintStatus.PENDING;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ComplaintPriority priority = ComplaintPriority.STANDARD;

    @OneToMany(mappedBy = "complaint", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<Evidence> evidences = new ArrayList<>();

    private String assignedTo;

    private String responsibleId;

    @Lob
    private String updateMessage;

    @OneToMany(mappedBy = "complaint", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<TimelineItem> timeline = new ArrayList<>();

    protected Complaint() { }

    public Complaint(CreateComplaintCommand command) {
        this.complaintId = new ComplaintId(generateComplaintId());
        this.category = command.category();
        this.department = command.department();
        this.city = command.city();
        this.district = command.district();
        this.location = command.location();
        this.referenceInfo = command.referenceInfo();
        this.description = command.description();
        this.priority = command.priority() != null ? command.priority() : ComplaintPriority.STANDARD;
        this.status = ComplaintStatus.PENDING;
        this.evidences = new ArrayList<>();

        // Initialize timeline with the five mandatory items in a deterministic order.
        // Note: database IDs for TimelineItem are generated by the DB, so we cannot
        // force numeric ids (1-5) here. We create five entries in order; the first
        // one is marked as current and completed with the registration message.
        java.time.LocalDateTime now = java.time.LocalDateTime.now();


        // 1) Complaint registered (current, completed)
        TimelineItem t1 = new TimelineItem(this, "Complaint registered", now, true, true, false);
        t1.setUpdateMessage("Complaint successfully registered in the system");
        this.timeline.add(t1);


        // 3) Awaiting response (not current, not completed)
        TimelineItem t2 = new TimelineItem(this, "Awaiting response", now, false, true, false);
        t2.setUpdateMessage("Your complaint is being processed, you will have a response soon.");
        this.timeline.add(t2);


        // 5) Rejected (not current, not completed)
        TimelineItem t3 = new TimelineItem(this, "Rejected", now, false, true, false);
        t3.setUpdateMessage("We apologize for the inconvenience, but your complaint will be rejected due to lack of evidence.");
        this.timeline.add(t3);

        // 6) Accepted (not current, not completed)
        TimelineItem t4 = new TimelineItem(this, "Accepted", now, false, true, false);
        t4.setUpdateMessage("Your complaint has been accepted and is being processed.");
        this.timeline.add(t4);

        // 7) Completed (not current, not completed)
        TimelineItem t5 = new TimelineItem(this, "Completed", now, false, true, false);
        t5.setUpdateMessage("Your complaint has been completed. Thank you for your support. The residents of your city appreciate such a noble act.");
        this.timeline.add(t5    );


    }



    public void updateComplaint(UpdateComplaintCommand command) {
        if (command.category() != null && !command.category().isEmpty()) {
            this.category = command.category();
        }
        if (command.department() != null && !command.department().isEmpty()) {
            this.department = command.department();
        }
        if (command.city() != null && !command.city().isEmpty()) {
            this.city = command.city();
        }
        if (command.district() != null && !command.district().isEmpty()) {
            this.district = command.district();
        }
        if (command.location() != null && !command.location().isEmpty()) {
            this.location = command.location();
        }
        if (command.referenceInfo() != null) {
            this.referenceInfo = command.referenceInfo();
        }
        if (command.description() != null && !command.description().isEmpty()) {
            this.description = command.description();
        }
        if (command.priority() != null) {
            this.priority = command.priority();
        }

        this.updateMessage = command.updateMessage();
        this.assignedTo = command.assignedTo();

        if (command.responsibleId() != null) {
            this.responsibleId = command.responsibleId();
        }

        if (command.status() != null) {
            this.status = command.status();
            updateTimelineFromStatus(command.status());
        }
    }


    public void assignTo(String assignedTo, String responsibleId) {
        this.assignedTo = assignedTo;
        this.responsibleId = responsibleId;
    }

    public void addEvidence(List<String> evidenceUrls) {
        if (evidenceUrls != null && !evidenceUrls.isEmpty()) {
            for (String url : evidenceUrls) {
                if (!isUrlAlreadyAdded(url)) {
                    Evidence evidence = new Evidence(this.getComplaintId(), url);
                    this.evidences.add(evidence);
                }
            }
        }
    }
    private boolean isUrlAlreadyAdded(String url) {
        return this.evidences.stream()
                .anyMatch(evidence -> evidence.getUrl().equals(url));
    }

    public List<String> getEvidence() {
        return evidences.stream()
                .map(Evidence::getUrl)
                .collect(Collectors.toList());
    }

    public List<Evidence> getEvidences() {
        return Collections.unmodifiableList(evidences);
    }

    public void setEvidences(List<Evidence> evidences) {
        this.evidences = new ArrayList<>(evidences);
    }
    public void updatePriority(ComplaintPriority priority) {
        this.priority = priority;
    }

    public void deleteComplaint() {
        this.status = ComplaintStatus.REJECTED;
    }

    /**
     * Add a timeline item that is not current and optionally not completed.
     * Used to pre-seed the timeline with fixed statuses.
     */
    private void addTimelineItemNonCurrent(String status, String message) {
        java.time.LocalDateTime now = java.time.LocalDateTime.now();
        TimelineItem timelineItem = new TimelineItem(this, status, now, false, false, false);
        timelineItem.setUpdateMessage(message != null ? message : "");
        this.timeline.add(timelineItem);
    }

    private String generateComplaintId() {
        return String.valueOf((int) (Math.random() * 900000) + 100000);
    }

    public String getComplaintId() {
        return this.complaintId != null ? this.complaintId.value() : null;
    }

    public Long getId() {
        return this.id;
    }

    @JsonProperty("assignedTo")
    public String getAssignedToForJson() {
        return this.assignedTo;
    }

    public String getCategory() {
        return this.category;
    }

    public String getCity() {
        return this.city;
    }

    public String getDepartment() {
        return this.department;
    }

    public String getDescription() {
        return this.description;
    }

    public String getDistrict() {
        return this.district;
    }



    public String getLocation() {
        return this.location;
    }

    @JsonProperty("priority")
    public String getPriorityForJson() {
        return this.priority != null ? this.priority.toJsonValue() : null;
    }

    public String getReferenceInfo() {
        return this.referenceInfo;
    }

    @JsonProperty("responsibleId")
    public String getResponsibleIdForJson() {
        return this.responsibleId;
    }

    @JsonProperty("status")
    public String getStatusForJson() {
        return this.status != null ? this.status.toJsonValue() : null;
    }

    public ComplaintStatus getStatus() {
        return this.status;
    }

    @JsonProperty("timeline")
    public List<TimelineItem> getTimelineForJson() {
        return this.timeline;
    }

    public String getUpdateDate() {
        return this.getUpdatedAt() != null ? this.getUpdatedAt().toString() : this.getCreatedAt().toString();
    }

    @JsonProperty("updateMessage")
    public String getUpdateMessageForJson() {
        return this.updateMessage;
    }

    public boolean isCitizenDeletable() {
        return this.status == ComplaintStatus.PENDING || this.status == ComplaintStatus.AWAITING_RESPONSE;
    }

    public ComplaintStatus getStatusEnum() {
        return this.status;
    }

    public ComplaintPriority getPriorityEnum() {
        return this.priority;
    }

    public Long getInternalId() {
        return this.id;
    }

    public ComplaintId getComplaintIdObject() {
        return this.complaintId;
    }
    public void setAssignedTo(String assignedTo) {
        this.assignedTo = assignedTo;
    }

    public void setResponsibleId(String responsibleId) {
        this.responsibleId = responsibleId;
    }

    public void setPriority(ComplaintPriority priority) {
        this.priority = priority;
    }


    public String getAssignedTo() {
        return assignedTo;
    }

    public String getResponsibleId() {
        return responsibleId;
    }

    public ComplaintPriority getPriority() {
        return priority;
    }


    // Getter
    public String getUpdateMessage() {
        return updateMessage;
    }

    // Getter
    public List<TimelineItem> getTimeline() {
        return timeline;
    }

    // Setters (opcional, si necesitas modificar los valores)
    public void setUpdateMessage(String updateMessage) {
        this.updateMessage = updateMessage;
    }

    public void setTimeline(List<TimelineItem> timeline) {
        this.timeline = timeline;
    }

    public void updateStatusFromTimeline() {
        if (this.timeline == null || this.timeline.isEmpty()) {
            this.status = ComplaintStatus.PENDING;
            return;
        }

        TimelineItem currentItem = this.timeline.stream()
                .filter(TimelineItem::isCurrent)
                .findFirst()
                .orElse(null);

        if (currentItem != null) {
            String statusText = currentItem.getStatus();
            this.updateMessage = currentItem.getUpdateMessage();

            switch (statusText) {
                case "Complaint registered":
                case "Under review":
                    this.status = ComplaintStatus.PENDING;
                    break;
                case "Awaiting response":
                case "Decision pending":
                    this.status = ComplaintStatus.AWAITING_RESPONSE;
                    break;
                case "Accepted":
                    this.status = ComplaintStatus.IN_PROCESS;
                    break;
                case "Rejected":
                    this.status = ComplaintStatus.REJECTED;
                    break;
                case "Completed":
                    this.status = ComplaintStatus.COMPLETED;
                    break;
                default:
                    this.status = ComplaintStatus.PENDING;
            }
        }
    }

    public void updateTimelineFromStatus() {
        updateTimelineFromStatus(this.status);
    }

    public void updateTimelineFromStatus(ComplaintStatus newStatus) {
        if (this.timeline == null || this.timeline.isEmpty()) {
            return;
        }

        for (TimelineItem item : this.timeline) {
            item.setCompleted(false);
            item.setCurrent(false);
            item.setWaitingDecision(false);
        }

        switch (newStatus) {
            case PENDING:
                for (TimelineItem item : this.timeline) {
                    if ("Complaint registered".equals(item.getStatus()) ||
                            "Under review".equals(item.getStatus())) {
                        item.setCompleted(true);
                        item.setCurrent(false);
                        item.setUpdateMessage("Complaint is in pending status");
                        break;
                    }
                }
                break;

            case AWAITING_RESPONSE:
                for (TimelineItem item : this.timeline) {
                    if ("Complaint registered".equals(item.getStatus()) ||
                            "Under review".equals(item.getStatus())) {
                        item.setCompleted(true);
                        item.setCurrent(false);
                        item.setUpdateMessage("Complaint is in pending status");
                    }


                    if ("Awaiting response".equals(item.getStatus()) ||
                            "Decision pending".equals(item.getStatus())) {
                        item.setCompleted(true);
                        item.setCurrent(false);
                        item.setWaitingDecision("Decision pending".equals(item.getStatus()));
                        item.setUpdateMessage("Awaiting response from authorities");
                        break;
                    }
                }
                break;

            case IN_PROCESS:
                for (TimelineItem item : this.timeline) {
                    if ("Accepted".equals(item.getStatus())) {
                        item.setCompleted(true);
                        item.setCurrent(false);
                        item.setUpdateMessage("Complaint is in process");
                        break;
                    }
                }
                break;

            case COMPLETED:
                for (TimelineItem item : this.timeline) {
                    if ("Completed".equals(item.getStatus())) {
                        item.setCompleted(true);
                        item.setCurrent(false);
                        item.setUpdateMessage("Complaint has been completed");
                        break;
                    }
                }
                break;

            case REJECTED:
                for (TimelineItem item : this.timeline) {
                    if ("Rejected".equals(item.getStatus())) {
                        item.setCompleted(true);
                        item.setCurrent(false);
                        item.setUpdateMessage("Complaint has been rejected");
                        break;
                    }
                }
                break;

            case ACCEPTED:
                for (TimelineItem item : this.timeline) {
                    if ("Accepted".equals(item.getStatus())) {
                        item.setCompleted(true);
                        item.setCurrent(false);
                        item.setUpdateMessage("Complaint has been accepted");
                        break;
                    }
                    if ("Complaint registered".equals(item.getStatus()) ||
                            "Under review".equals(item.getStatus())) {
                        item.setCompleted(true);
                        item.setCurrent(false);
                        item.setUpdateMessage("Complaint is in pending status");
                        break;
                    }
                        if ("Complaint registered".equals(item.getStatus()) ||
                                "Under review".equals(item.getStatus())) {
                            item.setCompleted(true);
                            item.setCurrent(false);
                            item.setUpdateMessage("Complaint is in pending status");
                        }


                        if ("Awaiting response".equals(item.getStatus()) ||
                                "Decision pending".equals(item.getStatus())) {
                            item.setCompleted(true);
                            item.setCurrent(false);
                            item.setWaitingDecision("Decision pending".equals(item.getStatus()));
                            item.setUpdateMessage("Awaiting response from authorities");
                        }
                }
                break;

            case UNDER_REVIEW:
                for (TimelineItem item : this.timeline) {
                    if ("Under review".equals(item.getStatus())) {
                        item.setCompleted(true);
                        item.setCurrent(false);
                        item.setUpdateMessage("Complaint is under review");
                        break;
                    }

                    if ("Complaint registered".equals(item.getStatus()) ||
                            "Under review".equals(item.getStatus())) {
                        item.setCompleted(true);
                        item.setCurrent(false);
                        item.setUpdateMessage("Complaint is in pending status");
                        break;
                    }
                }
                break;
        }

        for (TimelineItem item : this.timeline) {
            if (item.isCurrent()) {
                item.setDate(java.time.LocalDateTime.now());
            }
        }
    }

    public void setStatus(ComplaintStatus status) {
        this.status = status;
        updateTimelineFromStatus(status);
    }

    public void updateStatus(ComplaintStatus newStatus, String updateMessage) {
        this.status = newStatus;
        this.updateMessage = updateMessage;
        updateTimelineFromStatus(newStatus);

        if (this.timeline != null) {
            for (TimelineItem item : this.timeline) {
                if (item.isCurrent()) {
                    item.setUpdateMessage(updateMessage != null ? updateMessage : "");
                    break;
                }
            }
        }
    }
}
